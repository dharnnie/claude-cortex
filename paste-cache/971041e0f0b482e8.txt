Testing Conventions
Framework: RSpec + FactoryBot + Shoulda Matchers
Test Structure

# spec/models/order_spec.rb

require "rails_helper"

RSpec.describe Order do
describe "associations" do
it { is_expected.to belong_to(:user) }
it { is_expected.to have_many(:line_items).dependent(:destroy) }
end

describe "validations" do
it { is_expected.to validate_presence_of(:status) }
end

describe "scopes" do
describe ".recent" do
it "orders by created_at descending" do
old = create(:order, created_at: 1.day.ago)
new = create(:order, created_at: 1.hour.ago)

        expect(Order.recent).to eq([new, old])
      end
    end

end

describe "#cancelable?" do
context "when pending" do
subject { build(:order, status: :pending) }
it { is_expected.to be_cancelable }
end

    context "when delivered" do
      subject { build(:order, status: :delivered) }
      it { is_expected.not_to be_cancelable }
    end

end
end
Factory Guidelines

# spec/factories/orders.rb

FactoryBot.define do
factory :order do
user
status { "pending" }
total_cents { 0 }

    trait :with_items do
      transient do
        items_count { 3 }
      end

      after(:create) do |order, ctx|
        create_list(:line_item, ctx.items_count, order: order)
      end
    end

    trait :shipped do
      status { "shipped" }
      shipped_at { 1.day.ago }
    end

    trait :delivered do
      status { "delivered" }
      delivered_at { Time.current }
    end

end
end
Request Specs (API)

# spec/requests/api/v1/orders_spec.rb

require "rails_helper"

RSpec.describe "API V1 Orders" do
let(:user) { create(:user) }
let(:headers) { auth_headers(user) }

describe "GET /api/v1/orders" do
it "returns user's orders" do
create_list(:order, 3, user: user)

      get "/api/v1/orders", headers: headers

      expect(response).to have_http_status(:ok)
      expect(json_body["data"].size).to eq(3)
    end

end

describe "POST /api/v1/orders" do
let(:product) { create(:product) }
let(:params) do
{ order: { line_items: [{ product_id: product.id, qty: 2 }] } }
end

    it "creates order" do
      expect {
        post "/api/v1/orders", params: params, headers: headers
      }.to change(Order, :count).by(1)

      expect(response).to have_http_status(:created)
    end

end

private

def json_body
JSON.parse(response.body)
end
end
Service Specs

# spec/services/orders/create_service_spec.rb

require "rails_helper"

RSpec.describe Orders::CreateService do
let(:user) { create(:user) }
let(:product) { create(:product, price_cents: 1000) }
let(:params) { { product_id: product.id, quantity: 2 } }

describe ".call" do
context "with valid params" do
it "creates order" do
result = described_class.call(params, user)

        expect(result).to be_success
        expect(result.order).to be_persisted
        expect(result.order.total_cents).to eq(2000)
      end
    end

    context "with invalid params" do
      let(:params) { { product_id: nil } }

      it "returns failure" do
        result = described_class.call(params, user)

        expect(result).to be_failure
        expect(result.errors).to be_present
      end
    end

end
end
Test Helpers

# spec/support/auth_helpers.rb

module AuthHelpers
def auth_headers(user)
{ "Authorization" => "Bearer #{user.auth_token}" }
end
end

RSpec.configure do |config|
config.include AuthHelpers, type: :request
end
Best Practices

Use build over create when persistence isn't needed
Use let for lazy-loaded variables
Use let! only when eager loading is required
One assertion per test when possible
Use traits for common object states
Never test Rails internals (validations work, associations work)
Test YOUR code behavior
